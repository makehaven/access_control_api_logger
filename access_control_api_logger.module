<?php

/**
 * Implements hook_views_post_execute().
 */
function access_control_api_logger_views_post_execute(\Drupal\views\ViewExecutable $view) {
  if ($view->id() == 'access_api_v0') {
    // Determine which display is being used.
    $display_id = $view->current_display;

    // Initialize variables.
    $identifier = NULL;
    $permission_id = NULL;
    $type = NULL;

    // Get the source parameter from the request.
    $request = \Drupal::request();
    $source = $request->query->get('source', '');

    if ($display_id == 'access_api_v0_uuid_permission') {
      // UUID and permission ID from view arguments.
      $identifier = $view->args[0] ?? NULL;
      $permission_id = $view->args[1] ?? NULL;
      $type = 'uuid';

      if (!$identifier || !$permission_id) {
        return;
      }
    }
    elseif ($display_id == 'access_api_v0_serial_permission') {
      // Serial and permission ID from view arguments.
      $identifier = $view->args[0] ?? NULL;
      $permission_id = $view->args[1] ?? NULL;
      $type = 'serial';

      if (!$identifier || !$permission_id) {
        return;
      }
    }
    else {
      // Unknown display; do nothing.
      return;
    }

    // Pass the source to the log function.
    _access_control_api_logger_log_access_request($identifier, $permission_id, $type, $source);
  }
}

/**
 * Helper function to log the access control request.
 *
 * @param string $identifier
 *   The UUID or serial number.
 * @param string $permission_id
 *   The permission ID.
 * @param string $type
 *   The type of identifier ('uuid' or 'serial').
 * @param string $source
 *   The source of the access request.
 */
function _access_control_api_logger_log_access_request($identifier, $permission_id, $type = 'uuid', $source = '') {
  // Load user based on the identifier type.
  if ($type === 'uuid') {
    $users = \Drupal::entityTypeManager()->getStorage('user')->loadByProperties(['uuid' => $identifier]);
    $user = reset($users);

    if (!$user) {
      _access_control_api_logger_create_log(NULL, NULL, FALSE, 'Invalid user UUID.', $source);
      return;
    }
  }
  elseif ($type === 'serial') {
    $user = _access_control_api_logger_get_user_by_serial($identifier);

    if (!$user) {
      _access_control_api_logger_create_log(NULL, NULL, FALSE, 'Invalid serial number.', $source);
      return;
    }
  }
  else {
    return;
  }

  // Load all badge_request nodes for the user with status 'active'.
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'badge_request')
    ->condition('field_member_to_badge', $user->id())
    ->condition('field_badge_status.value', 'active')
    ->accessCheck(FALSE);

  $nids = $query->execute();

  if (empty($nids)) {
    _access_control_api_logger_create_log($user, NULL, FALSE, 'No active badge_request found for this user.', $source);
    return;
  }

  $badge_requests = \Drupal\node\Entity\Node::loadMultiple($nids);
  $access_granted = FALSE;
  $badge_term = NULL;

  foreach ($badge_requests as $badge_request) {
    $badge_term_ids = $badge_request->get('field_badge_requested')->getValue();

    if (empty($badge_term_ids)) {
      continue;
    }

    $badge_term_id = $badge_term_ids[0]['target_id'];
    $badge_term = \Drupal\taxonomy\Entity\Term::load($badge_term_id);

    if (!$badge_term) {
      continue;
    }

    $badge_text_id = strtolower($badge_term->get('field_badge_text_id')->value);

    if ($badge_text_id === strtolower($permission_id)) {
      $access_granted = TRUE;
      break;
    }
  }

  if ($access_granted) {
    _access_control_api_logger_create_log($user, $badge_term, TRUE, '', $source);
  }
  else {
    _access_control_api_logger_create_log($user, NULL, FALSE, 'No active badge_request found matching the permission ' . $permission_id . '.', $source);
  }
}

/**
 * Return TRUE if the ECK log entity type + bundle exist and are enabled.
 */
function _access_control_api_logger_log_is_available(): bool {
  if (!\Drupal::moduleHandler()->moduleExists('eck')) {
    return FALSE;
  }
  $cfg = \Drupal::config('eck.eck_entity_type.access_control_log');
  if (!$cfg || !$cfg->get('status')) {
    return FALSE;
  }
  $etm = \Drupal::entityTypeManager();
  if (!$etm->hasDefinition('access_control_log')) {
    return FALSE;
  }
  // ECK bundle config id: "<entity_type>.<bundle>".
  return (bool) $etm->getStorage('eck_type')->load('access_control_log.access_control_request');
}

/**
 * Creates an access control request log entry.
 *
 * @param \Drupal\user\Entity\User|null $user
 *   The user entity.
 * @param \Drupal\taxonomy\Entity\Term|null $badge
 *   The badge (permission) entity.
 * @param bool $result
 *   TRUE if access granted, FALSE otherwise.
 * @param string $note
 *   Additional information or reason for denial.
 * @param string $source
 *   The source of the access request.
 */
function _access_control_api_logger_create_log($user, $badge, $result, $note = '', $source = '') {
  // Only proceed if ECK entity + bundle are available.
  $etm = \Drupal::entityTypeManager();
  $bundles = \Drupal::service('entity_type.bundle.info')->getBundleInfo('access_control_log');
  if (!isset($bundles['access_control_request'])) {
    \Drupal::logger('access_control_api_logger')->warning('Skipping log write: access_control_request bundle not available.');
    return;
  }

  // Normalize inputs.
  $uid = $user ? (int) $user->id() : NULL;
  $permission_tid = $badge ? (int) $badge->id() : NULL;
  $granted = (bool) $result;
  $ts = \Drupal::time()->getRequestTime();

  try {
    // Create the ECK entity (this MUST be 'access_control_log' + 'access_control_request').
    /** @var \Drupal\Core\Entity\ContentEntityStorageInterface $storage */
    $storage = $etm->getStorage('access_control_log');

    $entity = $storage->create([
      'type' => 'access_control_request',
      'field_access_request_user' => $uid,
      'field_access_request_permission' => $permission_tid,
      'field_access_request_result' => $granted ? 1 : 0,
      'field_access_request_note' => $note ?: '',
      'field_access_request_source' => $source ?: '',
      'created' => $ts,
    ]);

    // Save (this is what fires our presence update).
    $entity->save();

    \Drupal::logger('access_control_api_logger')->notice(
      'Wrote access log entity id=@id uid=@uid perm=@perm result=@res source=@src',
      [
        '@id' => method_exists($entity, 'id') ? $entity->id() : 'n/a',
        '@uid' => $uid ?? 'NULL',
        '@perm' => $permission_tid ?? 'NULL',
        '@res' => $granted ? '1' : '0',
        '@src' => $source,
      ]
    );
  }
  catch (\Throwable $e) {
    \Drupal::logger('access_control_api_logger')->error('Failed to save access log: @m', ['@m' => $e->getMessage()]);
  }
}


/**
 * Helper function to find a user by serial number.
 *
 * @param string $serial
 *   The serial number.
 *
 * @return \Drupal\user\Entity\User|null
 *   The user entity or NULL if not found.
 */
function _access_control_api_logger_get_user_by_serial($serial) {
  // Load users where field_card_serial_number contains the serial number.
  $user_query = \Drupal::entityQuery('user')
    ->condition('field_card_serial_number', $serial)
    ->accessCheck(FALSE);

  $user_ids = $user_query->execute();

  if (!empty($user_ids)) {
    $users = \Drupal\user\Entity\User::loadMultiple($user_ids);
    return reset($users);
  }

  // Next, check the 'main' profile's field_card_serial_number field.
  $profile_query = \Drupal::entityQuery('profile')
    ->condition('type', 'main')
    ->condition('field_card_serial_number', $serial)
    ->accessCheck(FALSE);

  $profile_ids = $profile_query->execute();

  if (!empty($profile_ids)) {
    $profiles = \Drupal\profile\Entity\Profile::loadMultiple($profile_ids);
    foreach ($profiles as $profile) {
      $user = $profile->getOwner();
      if ($user) {
        return $user;
      }
    }
  }

  return NULL;
}
