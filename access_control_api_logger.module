<?php

/**
 * Implements hook_views_post_execute().
 */
function access_control_api_logger_views_post_execute(\Drupal\views\ViewExecutable $view) {
  if ($view->id() == 'access_api_v0') {
    // Determine which display is being used.
    $display_id = $view->current_display;

    // Initialize variables.
    $identifier = NULL;
    $permission_id = NULL;
    $type = NULL;

    // Get the source parameter from the request.
    $request = \Drupal::request();
    $source = $request->query->get('source', '');

    if ($display_id == 'access_api_v0_uuid_permission') {
      // UUID and permission ID from view arguments.
      $identifier = $view->args[0] ?? NULL;
      $permission_id = $view->args[1] ?? NULL;
      $type = 'uuid';

      if (!$identifier || !$permission_id) {
        return;
      }
    }
    elseif ($display_id == 'access_api_v0_serial_permission') {
      // Serial and permission ID from view arguments.
      $identifier = $view->args[0] ?? NULL;
      $permission_id = $view->args[1] ?? NULL;
      $type = 'serial';

      if (!$identifier || !$permission_id) {
        return;
      }
    }
    else {
      // Unknown display; do nothing.
      return;
    }

    // Pass the source to the log function.
    _access_control_api_logger_log_access_request($identifier, $permission_id, $type, $source);
  }
}

/**
 * Helper function to log the access control request.
 *
 * @param string $identifier
 *   The UUID or serial number.
 * @param string $permission_id
 *   The permission ID.
 * @param string $type
 *   The type of identifier ('uuid' or 'serial').
 * @param string $source
 *   The source of the access request.
 */
function _access_control_api_logger_log_access_request($identifier, $permission_id, $type = 'uuid', $source = '') {
  // Load user based on the identifier type.
  if ($type === 'uuid') {
    $users = \Drupal::entityTypeManager()->getStorage('user')->loadByProperties(['uuid' => $identifier]);
    $user = reset($users);

    if (!$user) {
      _access_control_api_logger_create_log(NULL, NULL, FALSE, 'Invalid user UUID.', $source);
      return;
    }
  }
  elseif ($type === 'serial') {
    $user = _access_control_api_logger_get_user_by_serial($identifier);

    if (!$user) {
      _access_control_api_logger_create_log(NULL, NULL, FALSE, 'Invalid serial number.', $source);
      return;
    }
  }
  else {
    return;
  }

  // Load all badge_request nodes for the user with status 'active'.
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'badge_request')
    ->condition('field_member_to_badge', $user->id())
    ->condition('field_badge_status.value', 'active')
    ->accessCheck(FALSE);

  $nids = $query->execute();

  if (empty($nids)) {
    _access_control_api_logger_create_log($user, NULL, FALSE, 'No active badge_request found for this user.', $source);
    return;
  }

  $badge_requests = \Drupal\node\Entity\Node::loadMultiple($nids);
  $access_granted = FALSE;
  $badge_term = NULL;

  foreach ($badge_requests as $badge_request) {
    $badge_term_ids = $badge_request->get('field_badge_requested')->getValue();

    if (empty($badge_term_ids)) {
      continue;
    }

    $badge_term_id = $badge_term_ids[0]['target_id'];
    $badge_term = \Drupal\taxonomy\Entity\Term::load($badge_term_id);

    if (!$badge_term) {
      continue;
    }

    $badge_text_id = strtolower($badge_term->get('field_badge_text_id')->value);

    if ($badge_text_id === strtolower($permission_id)) {
      $access_granted = TRUE;
      break;
    }
  }

  if ($access_granted) {
    _access_control_api_logger_create_log($user, $badge_term, TRUE, '', $source);
  }
  else {
    _access_control_api_logger_create_log($user, NULL, FALSE, 'No active badge_request found matching the permission ' . $permission_id . '.', $source);
  }
}

/**
 * Returns TRUE if the ECK log entity type + bundle are available & enabled.
 */
function _access_control_api_logger_log_is_available(): bool {
  // ECK must be enabled.
  if (!\Drupal::moduleHandler()->moduleExists('eck')) {
    return FALSE;
  }

  // Entity type must be enabled in active config.
  $cfg = \Drupal::config('eck.eck_entity_type.access_control_log');
  if (!$cfg || !$cfg->get('status')) {
    return FALSE;
  }

  // Entity type definition must exist.
  $etm = \Drupal::entityTypeManager();
  if (!$etm->hasDefinition('access_control_log')) {
    return FALSE;
  }

  // Bundle must exist (ECK bundle config id format: "<entity_type>.<bundle>").
  $bundle = $etm->getStorage('eck_type')->load('access_control_log.access_control_request');
  return (bool) $bundle;
}

/**
 * Creates an access control request log entry.
 *
 * @param \Drupal\user\Entity\User|null $user
 *   The user entity.
 * @param \Drupal\taxonomy\Entity\Term|null $badge
 *   The badge (permission) entity.
 * @param bool $result
 *   TRUE if access granted, FALSE otherwise.
 * @param string $note
 *   Additional information or reason for denial.
 * @param string $source
 *   The source of the access request.
 */
function _access_control_api_logger_create_log($user, $badge, $result, $note = '', $source = '') {
  // Guard: if entity type/bundle not available on this DB, skip logging (no 500).
  if (!_access_control_api_logger_log_is_available()) {
    \Drupal::logger('access_control_api_logger')->warning('Skipping log write: access_control_log bundle not available.');
    return;
  }

  try {
    $storage = \Drupal::entityTypeManager()->getStorage('access_control_log');
    $log_entry = $storage->create(['type' => 'access_control_request']);

    if ($user) {
      $log_entry->set('field_access_request_user', $user->id());
    }
    if ($badge) {
      $log_entry->set('field_access_request_permission', $badge->id());
    }

    $log_entry->set('field_access_request_result', $result ? 1 : 0);

    if ($note !== '') {
      $log_entry->set('field_access_request_note', $note);
    }
    if ($source !== '') {
      $log_entry->set('field_access_request_source', $source);
    }
    if (isset($_SERVER['REQUEST_METHOD'])) {
      $log_entry->set('field_access_request_method', $_SERVER['REQUEST_METHOD']);
    }

    $log_entry->save();
  }
  catch (\Throwable $e) {
    // Never take down the APIâ€”log and continue.
    \Drupal::logger('access_control_api_logger')->error('Failed to write access log: @msg', ['@msg' => $e->getMessage()]);
  }
}

/**
 * Helper function to find a user by serial number.
 *
 * @param string $serial
 *   The serial number.
 *
 * @return \Drupal\user\Entity\User|null
 *   The user entity or NULL if not found.
 */
function _access_control_api_logger_get_user_by_serial($serial) {
  // Load users where field_card_serial_number contains the serial number.
  $user_query = \Drupal::entityQuery('user')
    ->condition('field_card_serial_number', $serial)
    ->accessCheck(FALSE);

  $user_ids = $user_query->execute();

  if (!empty($user_ids)) {
    $users = \Drupal\user\Entity\User::loadMultiple($user_ids);
    return reset($users);
  }

  // Next, check the 'main' profile's field_card_serial_number field.
  $profile_query = \Drupal::entityQuery('profile')
    ->condition('type', 'main')
    ->condition('field_card_serial_number', $serial)
    ->accessCheck(FALSE);

  $profile_ids = $profile_query->execute();

  if (!empty($profile_ids)) {
    $profiles = \Drupal\profile\Entity\Profile::loadMultiple($profile_ids);
    foreach ($profiles as $profile) {
      $user = $profile->getOwner();
      if ($user) {
        return $user;
      }
    }
  }

  return NULL;
}
