<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\user\UserInterface;

/**
 * Implements hook_views_post_execute().
 */
function access_control_api_logger_views_post_execute(\Drupal\views\ViewExecutable $view) {
  if ($view->id() == 'access_api_v0') {
    // Determine which display is being used.
    $display_id = $view->current_display;

    // Initialize variables.
    $identifier = NULL;
    $permission_id = NULL;
    $type = NULL;

    // Get the source parameter from the request.
    $request = \Drupal::request();
    $source = $request->query->get('source', '');

    if ($display_id == 'access_api_v0_uuid_permission') {
      // UUID and permission ID from view arguments.
      $identifier = $view->args[0] ?? NULL;
      $permission_id = $view->args[1] ?? NULL;
      $type = 'uuid';

      if (!$identifier || !$permission_id) {
        return;
      }
    }
    elseif ($display_id == 'access_api_v0_serial_permission') {
      // Serial and permission ID from view arguments.
      $identifier = $view->args[0] ?? NULL;
      $permission_id = $view->args[1] ?? NULL;
      $type = 'serial';

      if (!$identifier || !$permission_id) {
        return;
      }
    }
    else {
      // Unknown display; do nothing.
      return;
    }

    // Pass the source to the log function.
    _access_control_api_logger_log_access_request($identifier, $permission_id, $type, $source);
  }
}

/**
 * Helper function to log the access control request.
 *
 * @param string $identifier
 *   The UUID or serial number.
 * @param string $permission_id
 *   The permission ID.
 * @param string $type
 *   The type of identifier ('uuid' or 'serial').
 * @param string $source
 *   The source of the access request.
 */
function _access_control_api_logger_log_access_request($identifier, $permission_id, $type = 'uuid', $source = '') {
  // Load user based on the identifier type.
  if ($type === 'uuid') {
    $users = \Drupal::entityTypeManager()->getStorage('user')->loadByProperties(['uuid' => $identifier]);
    $user = reset($users);

    if (!$user) {
      _access_control_api_logger_create_log(NULL, NULL, FALSE, 'Invalid user UUID.', $source);
      return;
    }
  }
  elseif ($type === 'serial') {
    $user = _access_control_api_logger_get_user_by_serial($identifier);

    if (!$user) {
      _access_control_api_logger_create_log(NULL, NULL, FALSE, 'Invalid serial number.', $source);
      return;
    }
  }
  else {
    return;
  }

  // Load all badge_request nodes for the user with status 'active'.
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'badge_request')
    ->condition('field_member_to_badge', $user->id())
    ->condition('field_badge_status.value', 'active')
    ->accessCheck(FALSE);

  $nids = $query->execute();

  if (empty($nids)) {
    _access_control_api_logger_create_log($user, NULL, FALSE, 'No active badge_request found for this user.', $source);
    return;
  }

  $badge_requests = \Drupal\node\Entity\Node::loadMultiple($nids);
  $access_granted = FALSE;
  $badge_term = NULL;

  foreach ($badge_requests as $badge_request) {
    $badge_term_ids = $badge_request->get('field_badge_requested')->getValue();

    if (empty($badge_term_ids)) {
      continue;
    }

    $badge_term_id = $badge_term_ids[0]['target_id'];
    $badge_term = \Drupal\taxonomy\Entity\Term::load($badge_term_id);

    if (!$badge_term) {
      continue;
    }

    $badge_text_id = strtolower($badge_term->get('field_badge_text_id')->value);

    if ($badge_text_id === strtolower($permission_id)) {
      $access_granted = TRUE;
      break;
    }
  }

  if ($access_granted) {
    _access_control_api_logger_create_log($user, $badge_term, TRUE, '', $source);
  }
  else {
    _access_control_api_logger_create_log($user, NULL, FALSE, 'No active badge_request found matching the permission ' . $permission_id . '.', $source);
  }
}

/**
 * Return TRUE if the ECK log entity type + bundle exist and are enabled.
 */
function _access_control_api_logger_log_is_available(): bool {
  if (!\Drupal::moduleHandler()->moduleExists('eck')) {
    return FALSE;
  }
  $cfg = \Drupal::config('eck.eck_entity_type.access_control_log');
  if (!$cfg || !$cfg->get('status')) {
    return FALSE;
  }
  $etm = \Drupal::entityTypeManager();
  if (!$etm->hasDefinition('access_control_log')) {
    return FALSE;
  }
  // ECK bundle config id: "<entity_type>.<bundle>".
  return (bool) $etm->getStorage('eck_type')->load('access_control_log.access_control_request');
}

/**
 * Creates an access control request log entry.
 *
 * @param \Drupal\user\Entity\User|null $user
 *   The user entity.
 * @param \Drupal\taxonomy\Entity\Term|null $badge
 *   The badge (permission) entity.
 * @param bool $result
 *   TRUE if access granted, FALSE otherwise.
 * @param string $note
 *   Additional information or reason for denial.
 * @param string $source
 *   The source of the access request.
 */
function _access_control_api_logger_create_log($user, $badge, $result, $note = '', $source = '') {
  // Only proceed if ECK entity + bundle are available.
  $etm = \Drupal::entityTypeManager();
  $bundles = \Drupal::service('entity_type.bundle.info')->getBundleInfo('access_control_log');
  if (!isset($bundles['access_control_request'])) {
    \Drupal::logger('access_control_api_logger')->warning('Skipping log write: access_control_request bundle not available.');
    return;
  }

  // Normalize inputs.
  $uid = $user ? (int) $user->id() : NULL;
  $permission_tid = $badge ? (int) $badge->id() : NULL;
  $granted = (bool) $result;
  $ts = \Drupal::time()->getRequestTime();

  try {
    // Create the ECK entity (this MUST be 'access_control_log' + 'access_control_request').
    /** @var \Drupal\Core\Entity\ContentEntityStorageInterface $storage */
    $storage = $etm->getStorage('access_control_log');

    $entity = $storage->create([
      'type' => 'access_control_request',
      'field_access_request_user' => $uid,
      'field_access_request_permission' => $permission_tid,
      'field_access_request_result' => $granted ? 1 : 0,
      'field_access_request_note' => $note ?: '',
      'field_access_request_source' => $source ?: '',
      'created' => $ts,
    ]);

    // Save (this is what fires our presence update).
    $entity->save();

    \Drupal::logger('access_control_api_logger')->notice(
      'Wrote access log entity id=@id uid=@uid perm=@perm result=@res source=@src',
      [
        '@id' => method_exists($entity, 'id') ? $entity->id() : 'n/a',
        '@uid' => $uid ?? 'NULL',
        '@perm' => $permission_tid ?? 'NULL',
        '@res' => $granted ? '1' : '0',
        '@src' => $source,
      ]
    );
  }
  catch (\Throwable $e) {
    \Drupal::logger('access_control_api_logger')->error('Failed to save access log: @m', ['@m' => $e->getMessage()]);
  }
}

/**
 * Implements hook_cron().
 */
function access_control_api_logger_cron() {
  $config = \Drupal::config('access_control_api_logger.settings');
  $cache_enabled = $config->get('fallback_cache_enabled');
  if ($cache_enabled === FALSE) {
    return;
  }
  if (($config->get('fallback_cache_refresh_cron') ?? TRUE) === FALSE) {
    return;
  }

  try {
    \Drupal::service('access_control_api_logger.fallback_store_cache')->warmCache();
  }
  catch (\Throwable $e) {
    \Drupal::logger('access_control_api_logger')->error('Unable to warm fallback cache during cron: @message', ['@message' => $e->getMessage()]);
  }
}

/**
 * Implements hook_entity_insert().
 */
function access_control_api_logger_entity_insert(EntityInterface $entity) {
  _access_control_api_logger_maybe_invalidate_fallback_cache($entity);
}

/**
 * Implements hook_entity_update().
 */
function access_control_api_logger_entity_update(EntityInterface $entity) {
  _access_control_api_logger_maybe_invalidate_fallback_cache($entity);
}

/**
 * Implements hook_entity_delete().
 */
function access_control_api_logger_entity_delete(EntityInterface $entity) {
  _access_control_api_logger_maybe_invalidate_fallback_cache($entity);
}

/**
 * Invalidate cached fallback data when relevant entities change.
 */
function _access_control_api_logger_maybe_invalidate_fallback_cache(EntityInterface $entity) {
  if (!_access_control_api_logger_entity_triggers_cache_invalidation($entity)) {
    return;
  }

  try {
    \Drupal::service('access_control_api_logger.fallback_store_cache')->invalidate();
  }
  catch (\Throwable $e) {
    \Drupal::logger('access_control_api_logger')->error('Unable to invalidate fallback cache: @message', ['@message' => $e->getMessage()]);
  }
}

/**
 * Determine if the entity change affects the fallback export.
 */
function _access_control_api_logger_entity_triggers_cache_invalidation(EntityInterface $entity): bool {
  $entity_type_id = $entity->getEntityTypeId();
  if ($entity_type_id === 'user') {
    return TRUE;
  }
  if ($entity_type_id === 'taxonomy_term' && $entity->bundle() === 'badges') {
    return TRUE;
  }
  if ($entity_type_id === 'node' && $entity->bundle() === 'badge_request') {
    return TRUE;
  }
  return FALSE;
}


/**
 * Helper function to find a user by serial number.
 *
 * @param string $serial
 *   The serial number.
 *
 * @return \Drupal\user\Entity\User|null
 *   The user entity or NULL if not found.
 */
function _access_control_api_logger_get_user_by_serial($serial) {
  // Load users where field_card_serial_number contains the serial number.
  $user_query = \Drupal::entityQuery('user')
    ->condition('field_card_serial_number', $serial)
    ->accessCheck(FALSE);

  $user_ids = $user_query->execute();

  if (!empty($user_ids)) {
    $users = \Drupal\user\Entity\User::loadMultiple($user_ids);
    return reset($users);
  }

  // Next, check the 'main' profile's field_card_serial_number field.
  $profile_query = \Drupal::entityQuery('profile')
    ->condition('type', 'main')
    ->condition('field_card_serial_number', $serial)
    ->accessCheck(FALSE);

  $profile_ids = $profile_query->execute();

  if (!empty($profile_ids)) {
    $profiles = \Drupal\profile\Entity\Profile::loadMultiple($profile_ids);
    foreach ($profiles as $profile) {
      $user = $profile->getOwner();
      if ($user) {
        return $user;
      }
    }
  }

  return NULL;
}

/**
 * Implements hook_theme().
 */
function access_control_api_logger_theme(): array {
  return [
    'access_control_user_status_block' => [
      'variables' => [
        'summary' => [],
        'items' => [],
        'link_groups' => [],
      ],
      'template' => 'access-control-user-status-block',
    ],
  ];
}

/**
 * Implements hook_access_control_api_logger_user_admin_links().
 */
function access_control_api_logger_access_control_api_logger_user_admin_links(UserInterface $account, AccountInterface $viewer): array {
  $links = [];

  if ($viewer->hasPermission('access civicrm')) {
    $contact_id = access_control_api_logger_get_civicrm_contact_id($account);
    if ($contact_id) {
      $links[] = [
        'id' => 'civicrm_contact',
        'title' => t('Open in CiviCRM'),
        'url' => Url::fromUri('internal:/civicrm/contact/view', [
          'query' => [
            'reset' => 1,
            'cid' => $contact_id,
          ],
          'attributes' => [
            'target' => '_blank',
            'rel' => 'noopener',
          ],
        ]),
        'description' => t('Review the synced CiviCRM contact.'),
        'category' => t('CRM'),
        'weight' => -100,
      ];
    }
  }

  $chargebee_url = access_control_api_logger_get_chargebee_subscription_url($account);
  if ($chargebee_url) {
    $links[] = [
      'id' => 'chargebee_subscription',
      'title' => t('Chargebee Subscription'),
      'url' => $chargebee_url,
      'description' => t('Open the member subscription in Chargebee.'),
      'category' => t('Billing'),
      'weight' => -50,
    ];
  }

  return $links;
}

/**
 * Resolve the CiviCRM contact id for a Drupal user.
 */
function access_control_api_logger_get_civicrm_contact_id(UserInterface $account): ?int {
  if (!\Drupal::moduleHandler()->moduleExists('civicrm')) {
    return NULL;
  }

  // Prefer the helper from sync_roles_civi_bridge when available.
  if (function_exists('sync_roles_bridge_get_contact_id')) {
    try {
      $logger = \Drupal::logger('access_control_api_logger');
      /** @var \Drupal\civicrm\Civicrm $civicrm */
      $civicrm = \Drupal::service('civicrm');
      $contact_id = sync_roles_bridge_get_contact_id($account, $logger, $civicrm);
      if ($contact_id) {
        return (int) $contact_id;
      }
    }
    catch (\Throwable $throwable) {
      \Drupal::logger('access_control_api_logger')->warning('Unable to read CiviCRM contact id via sync bridge: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  if (!function_exists('civicrm_api3')) {
    return NULL;
  }

  try {
    /** @var \Drupal\civicrm\Civicrm $civicrm */
    $civicrm = \Drupal::service('civicrm');
    $civicrm->initialize();

    $uf_match = civicrm_api3('UFMatch', 'get', [
      'sequential' => 1,
      'uf_id' => $account->id(),
      'check_permissions' => 0,
      'options' => ['limit' => 1],
    ]);
    if (!empty($uf_match['values'][0]['contact_id'])) {
      return (int) $uf_match['values'][0]['contact_id'];
    }
  }
  catch (\Throwable $throwable) {
    \Drupal::logger('access_control_api_logger')->warning('Unable to resolve CiviCRM contact id: @message', [
      '@message' => $throwable->getMessage(),
    ]);
  }
  return NULL;
}

/**
 * Builds the Chargebee subscription URL for an account if available.
 */
function access_control_api_logger_get_chargebee_subscription_url(UserInterface $account): ?Url {
  if (!$account->hasField('field_user_chargebee_id')) {
    return NULL;
  }
  $subscription_id = trim((string) $account->get('field_user_chargebee_id')->value);
  if ($subscription_id === '') {
    return NULL;
  }

  $config = \Drupal::config('access_control_api_logger.settings');
  $base = trim((string) $config->get('chargebee_dashboard_base'));
  if ($base === '') {
    $base = 'https://makehaven.chargebee.com';
  }
  $base = rtrim($base, '/');

  return Url::fromUri($base . '/d/subscriptions/' . $subscription_id, [
    'attributes' => [
      'target' => '_blank',
      'rel' => 'noopener',
    ],
  ]);
}
